#Лабораторные работы по курсу "Архитектура операционных систем"

## Лабораторная работа 1. Файлы и устройства ввода/вывода
### Задание
1. Написать программу, которая выполняет некоторый системный вызов, например open, и затем выводит возвращаемую ошибку. Использовать в программе разные способы вывода сообщения об ошибке: вывод значения '''errno''', вывод соответствующего сообщения из системного массива сообщений об ошибках '''sys_errlist[]''', вызов библиотечной функции '''perror'''.
2. Создать новый файл с правом только на чтение (имя файла и права доступа ввести из командной строки), записать в него несколько строк, закрыть. Повторно открыть данный файл на чтение, прочитать из него информацию и вывести ее на экран, закрыть. Еще раз открыть этот же файл на чтение и запись, проверить результат системного вызова open. Объяснить полученные результаты.
3. Повторно выполнить программу п. 2 с теми же исходными данными. Проверить результаты выполнения каждого системного вызова. Объяснить полученные результаты.
4. Используя программу п. 2, создать новый файл с правами на чтение и запись. Выполнить любые операции с файлом (чтение и/или запись), используя разные способы позиционирования. Объяснить полученные результаты.
5. Повторно выполнить программу п. 4. Проверить результаты выполнения каждого системного вызова. Объяснить полученные результаты.
6. Модифицировать программу п. 4 для создания разреженного файла.
7. Написать программу для получения справочной информации о файлах с помощью системного вызова '''stat'''. Имя файла передается в программу из командной строки. Получить справочную информацию для различных типов файлов (обычный файл, каталог, специальные байт- и блок-ориентированные файлы).
8. Написать программу копирования одного файла в другой. Имена файлов задаются в командной строке (первый аргумент - исходный файл, второй - результирующий). Если аргументы командной строки отсутствуют, использовать стандартный ввод и стандартный вывод. Копирование файлов выполнить с помощью функции.
9. Изменить программу п. 8 таким образом, чтобы функция копирования
использовала стандартные ввод и вывод, а вызывающая программа переназначала стандартные ввод и вывод на указанные в аргументах командной строки файлы.
10. Написать программу, которая выводит на экран содержимое файла в обратном порядке: сначала выводится последний символ файла, затем предпоследний и так далее до первого. Использовать '''lseek''' и '''read'''.
11. Написать программу, которая определяет, какой файл из перечисленных в командной строке имеет наибольшую длину. Вывести длину файла в байтах.

## Лабораторная работа 2. Управление процессами
### Задание
1. Написать программу, которая добавляет новые строки в среду процесса.
2. Кто выполняется первым после '''fork''': отец или сын? Написать программу, которую можно использовать для проверки данной ситуации.
3. Написать программу, в которой процесс порождает новый и позволяет порожденному процессу завершиться. Оба процесса должны выводить свои идентификаторы (процесса, родительского процесса, группы процессов). Проверить идентификатор и статус завершения порожденного процесса. Выполнить данную программу и посмотреть ее результаты.
4. Изменить программу п. 3 так, чтобы родительский процесс завершился раньше порожденного. Какой процесс становится родительским для порожденного после того, как исходный родительский процесс завершился?
5. Изменить программу п. 3 так, чтобы родительский процесс выполнялся, не ожидая завершения порожденного процесса. Что произойдет с порожденным процессом, когда он завершится? Как убить зомби?
6. Изменить программу п. 3 так, чтобы оба процесса выполняли системный вызов pause после вывода идентификаторов. Запустить программу в фоновом режиме и посмотрите (с помощью '''ps'''), какие процессы существуют для данного пользователя. Выполнить '''kill -9 <pid>''' для родительского процесса. Что произойдет с порожденным? После очистки текущего сеанса, вновь выполнить программу, но уже в интерактивном режиме. Нажать на терминале клавишу '''CTRL-C'''. Что произойдет с родительским и порожденным процессами? Можно ли получить такой же результат, если нажать клавишу прерывания после того, как родительский процесс завершится?
7. Модифицировать программу, включив в нее '''setpgrp''' в порожденный процесс до того, как он будет выполнять '''pause'''. Повлияет ли на порожденный процесс нажатие клавиши прерывания в тот момент, когда родительский процесс "спит"? Будет ли показан порожденный процесс в выводе команды '''ps'''?
8. Открыть файл (достаточно большого размера), доступный для чтения. Имя файла передается из командной строки. После открытия файла создать параллельный процесс с помощью только '''fork'''. В обоих процессах создать свои файлы для записи, читать информацию из общего файла и копировать ее в собственные выходные файлы (не на экран). Вывести на экран содержимое полученных файлов из порожденного процесса по окончании записи в файл и из родительского процесса, дождавшись завершения порожденного процесса. Посмотреть, что изменится, если читаемую процессами информацию сразу выводить на экран.
9. Выполнить п. 8 при условии, что общий файл для чтения открывается в каждом из порожденных процессов.
10. Создать (с помощью связки '''fork - exec''') параллельный процесс. Имя исполняемого файла для exec передается с помощью аргумента командной строки. Передать в порожденный процесс некоторую информацию через список параметров (список аргументов в функции '''main'''). Каждый процесс (и родительский, и порожденный) должен вывести на экран список переданных ему аргументов и свое окружение.
11. Выполнить из программы на Си какую-либо команду Shell ('''cp''' или '''ls'''): с помощью вызовов '''fork-exec''', с помощью библиотечной функции '''system'''. Необходимые для команды данные передать через аргументы командной строки.
